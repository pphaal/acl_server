#!/usr/bin/env python
### BEGIN INIT INFO
# Provides:          acl_server
# Required-Start:    $acltool $network
# Required-Stop:     $acltool $network
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: ACL REST Daemon
# Description:       REST API for adding / removing ACLs 
### END INIT INFO

from BaseHTTPServer import BaseHTTPRequestHandler,HTTPServer
from os.path import isfile
from uuid import uuid4
from json import dumps,loads
from subprocess import Popen,STDOUT,PIPE
from threading import Thread,Lock
from time import sleep
from daemon import runner
from filecmp import cmp
import re, stat, os

class CommitTask:
  lastError = None
  commit_t = None
  commit_requests = 0
  commit_processed = 0
  lock = Lock()

  def do_commit(self):
    changed = True
    while changed:
      self.lock.acquire()
      try:
        requests = self.commit_requests
      finally:
        self.lock.release()
      child = Popen(["cl-acltool","-i"],stderr=STDOUT,stdout=PIPE)
      s = child.communicate()[0]
      if child.returncode:
        self.lastError = {'returncode':child.returncode, 'lines': s.splitlines()}
      else:
        self.lastError = None
      self.lock.acquire()
      try:
        self.commit_processed = requests
        if self.commit_requests != requests:
          changed = True
        else:
          changed = False
          self.commit_t = None
      finally:
        self.lock.release()
      if changed:
        sleep(0.5)

  def commit(self):
    self.lock.acquire()
    try:
      self.commit_requests = self.commit_requests + 1
      if self.commit_t == None:
        self.commit_t = Thread(target=self.do_commit)
        self.commit_t.start()
    finally:
      self.lock.release()

class ACLRequestHandler(BaseHTTPRequestHandler):
  uripat = re.compile('^/acl/([a-z0-9_]+)$')
  dir = '/etc/cumulus/acl/policy.d/'
  priority = '50'
  prefix = 'rest-'
  bld = '.bld'
  suffix = '.rules'
  filepat = re.compile('^'+priority+prefix+'([a-z0-9_]+)\\'+suffix+'$')

  @staticmethod
  def dequote(s):
    if (s[0] == s[-1]) and s.startswith(("'", '"')):
      return s[1:-1]
    return s

  @classmethod
  def log_message(cls,format,*args):
    return

  @classmethod
  def commit(cls):
     if cls.commitTask:
       cls.commitTask.commit() 

  @classmethod
  def lastError(cls):
    if cls.commitTask:
       return cls.commitTask.lastError
    else:
       return None

  @classmethod
  def bldfile(cls,name):
    return cls.dir+str(uuid4())+cls.bld

  @classmethod
  def aclfile(cls,name):
    return cls.dir+cls.priority+cls.prefix+name+cls.suffix

  def wheaders(self,status,checkLastError=False):
    self.send_response(status)
    self.send_header('Accept','application/json')
    self.send_header('Content-Type','application/json')
    if checkLastError:
      lastError = self.lastError();
      if lastError:
        self.send_header('Warning','199 - "check lasterror"')
    self.end_headers() 

  def do_PUT(self):
    m = self.uripat.match(self.path)
    if None != m:
       name = m.group(1)
       if 'lasterror' == name:
         self.wheaders(403)
       else:
         if not 'application/json' in self.headers.getheader('content-type'):
           self.wheaders(406)
           return
         len = int(self.headers.getheader('content-length'))
         data = self.rfile.read(len)
         try: 
           lines = loads(data)
         except ValueError:
           self.wheaders(400,checkLastError=True)
           return
         fn = self.bldfile(name)
         mode = stat.S_IWUSR | stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH
         umask_original = os.umask(0)
         try:
           f = os.fdopen(os.open(fn, os.O_WRONLY | os.O_CREAT | os.O_TRUNC, mode), 'w')
         finally:
           os.umask(umask_original)
         f.write('\n'.join(lines) + '\n')
         f.flush()
         os.fsync(f.fileno())
         f.close()
         tgtname = self.aclfile(name)
         if isfile(tgtname) and cmp(fn,tgtname,False):
             os.remove(fn)
         else:
             os.rename(fn,tgtname)
             self.commit()
         self.wheaders(202,checkLastError=True)
    else:
      self.wheaders(404)
 
  def do_DELETE(self):
    m = self.uripat.match(self.path)
    if None != m:
       name = m.group(1)
       if 'lasterror' == name:
         self.wheaders(403)
       else:
         fn = self.aclfile(name)
         if isfile(fn):
           os.remove(fn)
           self.commit()
         self.wheaders(204,checkLastError=True)
    elif '/acl/' == self.path:
       for file in os.listdir(self.dir):
         m = self.filepat.match(file)
         if None != m:
           os.remove(self.dir+file)
       self.commit()
       self.wheaders(204,checkLastError=True)
    else:
       self.wheaders(404,checkLastError=True)

  def do_GET(self):
    m = self.uripat.match(self.path)
    if None != m:
       name = m.group(1)
       if 'lasterror' == name:
         lastError = self.lastError()
         if lastError:
            self.wheaders(200)
            self.wfile.write(dumps(lastError,indent=1,sort_keys=True))
         else:
            self.wheaders(204) 
       else:
         fn = self.aclfile(name)
         if isfile(fn):
           result = []
           with open(fn) as f:
             for line in f:
               result.append(line.rstrip('\n'))
           self.wheaders(200,checkLastError=True)
           self.wfile.write(dumps(result,indent=1,sort_keys=True))
         else:
           self.wheaders(404,checkLastError=True)
    elif '/acl/' == self.path:
       result = []
       for file in os.listdir(self.dir):
         m = self.filepat.match(file)
         if None != m:
           name = m.group(1)
           result.append(name)
       self.wheaders(200,checkLastError=True)
       self.wfile.write(dumps(result,indent=1,sort_keys=True))
    elif '/lldp/neighbors' == self.path:
       child = Popen(["lldpcli","-f","json","show","neighbors","summary"],stderr=None,stdout=PIPE)
       s = child.communicate()[0]
       if child.returncode:
         self.wheaders(500)
       else:
         self.wheaders(200)
         self.wfile.write(s.rstrip())
    elif '/lldp/configuration' == self.path:
       child = Popen(["lldpcli","-f","json","show","configuration"],stderr=None,stdout=PIPE);
       s = child.communicate()[0]
       if child.returncode:
          self.wheaders(500)
       else:
          self.wheaders(200)
          self.wfile.write(s.rstrip())
    elif '/hostname' == self.path:
       child = Popen(["uname","-n"],stderr=None,stdout=PIPE);
       s = child.communicate()[0]
       if child.returncode:
          self.wheaders(500)
       else:
          self.wheaders(200)
          self.wfile.write(dumps(s.rstrip())) 
    elif '/ptm' == self.path:
       dotfile = '/etc/ptm.d/topology.dot'
       if isfile(dotfile):
         topo = {'links':{}}
         with open(dotfile) as f:
           l = 1
           for line in f:
             link = re.search('([\S]+):(\S+)\s*(--|->)\s*(\S+):([^\s;,]+)',line)
             if link:
                s1 = self.dequote(link.group(1))
                p1 = self.dequote(link.group(2))
                s2 = self.dequote(link.group(4))
                p2 = self.dequote(link.group(5))
                linkname = 'L%d' % (l)
                topo['links'][linkname] = {'node1':s1,'port1':p1,'node2':s2,'port2':p2}
                l += 1
         self.wheaders(200)
         self.wfile.write(dumps(topo,indent=1,sort_keys=True))
       else:
         self.wheaders(404)
    else:
       self.wheaders(404)

class ACLDaemon():
  def __init__(self):
    self.stdin_path = '/dev/null'
    self.stdout_path = '/dev/tty'
    self.stderr_path = '/dev/tty'
    self.pidfile_path = '/var/run/acl_server.pid'
    self.pidfile_timeout = 5
  def run(self):
    commit = CommitTask()
    ACLRequestHandler.commitTask = commit
    server = HTTPServer(('',8080), ACLRequestHandler) 
    server.serve_forever()

app = ACLDaemon()
daemon_runner = runner.DaemonRunner(app)
daemon_runner.do_action() 
